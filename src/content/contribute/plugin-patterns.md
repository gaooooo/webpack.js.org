---
title: 插件模式
sort: 5
---

插件授予无限的机会在webpack构建系统中执行自定义。 这使您可以创建自定义资源类型，执行独特的构建修改，甚至可以在使用中间件时增强webpack运行时。 以下是在编写插件时变得有用的webpack的一些功能。

## 探索资源，块，模块和依赖关系

编译完成后，编译中的所有结构都可以遍历。

```javascript
function MyPlugin() {}

MyPlugin.prototype.apply = function(compiler) {
  compiler.plugin('emit', function(compilation, callback) {

    // Explore each chunk (build output):
    compilation.chunks.forEach(function(chunk) {
      // Explore each module within the chunk (built inputs):
      chunk.modules.forEach(function(module) {
        // Explore each source file path that was included into the module:
        module.fileDependencies.forEach(function(filepath) {
          // we've learned a lot about the source structure now...
        });
      });

      // Explore each asset filename generated by the chunk:
      chunk.files.forEach(function(filename) {
        // Get the asset source for each file generated by the chunk:
        var source = compilation.assets[filename].source();
      });
    });

    callback();
  });
};

module.exports = MyPlugin;
```

- `compilation.modules`：编译中的模块数组（内置输入）。 每个模块管理源库中的原始文件的构建。
- `module.fileDependencies`：包含在模块中的一系列源文件路径。 这包括源JavaScript文件本身（如：index.js）以及它所需的所有依赖资源文件（样式表，图像等）。 查看依赖关系对于查看哪些源文件属于某个模块很有用。
- `compilation.chunks`：汇编中的一组块（构建输出）。 每个块管理最终呈现资产的组成。
- `chunk.modules`：包含在块中的模块数组。 通过扩展，您可以查看每个模块的依赖关系，以查看输入到块中的原始源文件。
- `chunk.files`：由块生成的输出文件名数组。 您可以从`compilation.assets`表中访问这些资产来源。

### Monitoring the watch graph

运行webpack中间件时，每个编译包括一个`fileDependencies`数组（正在监视哪些文件）和一个`fileTimestamps`哈希，它将观察到的文件路径映射到时间戳。 这些对于检测编译中哪些文件已经改变非常有用：

```javascript
function MyPlugin() {
  this.startTime = Date.now();
  this.prevTimestamps = {};
}

MyPlugin.prototype.apply = function(compiler) {
  compiler.plugin('emit', function(compilation, callback) {

    var changedFiles = Object.keys(compilation.fileTimestamps).filter(function(watchfile) {
      return (this.prevTimestamps[watchfile] || this.startTime) < (compilation.fileTimestamps[watchfile] || Infinity);
    }.bind(this));

    this.prevTimestamps = compilation.fileTimestamps;
    callback();
  }.bind(this));
};

module.exports = MyPlugin;
```

您也可以将新文件路径添加到监听中，以在这些文件更改时接收编译触发器。 只需将有效的文件路径推送到`compilation.fileDependencies`数组中即可将其添加到监听中。 注意：`fileDependencies`数组在每次编译时都会重建，因此您的插件必须将自己的监视依赖关系推送到每个编译中以保持它们不受监视。

## Changed chunks

类似于监视图，在监视编译过程中通过跟踪它们的散列哈希，更容易去监视被更改的块（or modules, for that matter）。

```javascript
function MyPlugin() {
  this.chunkVersions = {};
}

MyPlugin.prototype.apply = function(compiler) {
  compiler.plugin('emit', function(compilation, callback) {

    var changedChunks = compilation.chunks.filter(function(chunk) {
      var oldVersion = this.chunkVersions[chunk.name];
      this.chunkVersions[chunk.name] = chunk.hash;
      return chunk.hash !== oldVersion;
    }.bind(this));

    callback();
  }.bind(this));
};

module.exports = MyPlugin;
```
